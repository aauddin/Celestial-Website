<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Helios + Zodiac Wheel (Geocentric Approx)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #000;
      color: #fff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      overflow: hidden;
    }

    #wrapper {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #000;
    }

    /* Pure CSS border frame */
    #card {
      position: relative;
      width: min(95vmin, 1100px);
      padding: 22px 22px 16px;
      border-radius: 22px;
      box-sizing: border-box;
      background: transparent;
      border: 2px solid rgba(255, 215, 0, 0.65);
      box-shadow:
        inset 0 0 0 1.3px rgba(255, 215, 0, 0.22),
        0 0 28px rgba(255, 215, 0, 0.12);
    }

    #header {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 10px;
    }

    h1 {
      margin: 0 0 4px 0;
      font-weight: 500;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      font-size: 14px;
      text-align: center;
    }

    #subtitle {
      font-size: 11px;
      opacity: 0.7;
      margin-bottom: 8px;
      text-align: center;
      max-width: 900px;
    }

    #controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      opacity: 0.92;
    }

    #controls label {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    #controls input[type="date"],
    #controls select {
      background: #111;
      border: 1px solid #333;
      color: #fff;
      padding: 2px 4px;
      border-radius: 4px;
      font-size: 11px;
    }

    #controls button {
      background: #111;
      border: 1px solid #444;
      color: #fff;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 11px;
      cursor: pointer;
      transition: background 0.15s, border-color 0.15s;
    }

    #controls button:hover {
      background: #222;
      border-color: #888;
    }

    #controls .zoom-label {
      margin-left: 4px;
      opacity: 0.9;
    }

    /* live timestamp line */
    #statusbar{
      margin-top: 6px;
      font-size: 11px;
      opacity: 0.82;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
    }
    #statusbar .chip{
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,215,0,0.22);
      background: rgba(0,0,0,0.35);
      box-shadow: inset 0 0 0 1px rgba(255,215,0,0.08);
      white-space: nowrap;
    }

    /* Two canvases side-by-side */
    #panes {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 18px;
      align-items: center;
      justify-items: center;
      margin-top: 10px;
    }

    .pane {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      width: 100%;
    }

    .pane-title {
      font-size: 11px;
      opacity: 0.8;
      letter-spacing: 0.12em;
      text-transform: uppercase;
    }

    canvas {
      border-radius: 50%;
      width: min(42vmin, 460px);
      height: min(42vmin, 460px);
      box-shadow: 0 0 30px rgba(255, 215, 0, 0.22),
                  0 0 80px rgba(255, 215, 0, 0.10);
      background: radial-gradient(circle at center, #111 0%, #000 60%);
      display: block;
    }

    /* Legend: fixed grid rows of 3 */
    #legend {
      margin-top: 12px;
      font-size: 11px;
      opacity: 0.85;

      display: grid;
      grid-template-columns: repeat(3, auto);
      gap: 6px 16px;
      justify-content: center;
      align-items: center;
      text-align: left;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 4px;
      white-space: nowrap;
    }

    .legend-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex: 0 0 auto;
    }

    /* Planet colors */
    .sun     { background: #ffd700; }
    .mercury { background: #c0c0c0; }
    .venus   { background: #ffbf7f; }
    .earth   { background: #4cc9f0; }
    .mars    { background: #ff6b6b; }
    .jupiter { background: #ffdd99; }
    .saturn  { background: #f4e285; }
    .uranus  { background: #7fffd4; }
    .neptune { background: #6c5ce7; }
    .pluto   { background: #b388ff; }

    @media (max-width: 860px) {
      #panes { grid-template-columns: 1fr; }
      canvas { width: min(72vmin, 520px); height: min(72vmin, 520px); }
      #card { width: min(96vmin, 980px); }
    }
  </style>
</head>

<body>
  <div id="wrapper">
    <div id="card">

      <div id="header">
        <h1>HELIOS + ZODIAC WHEEL</h1>
        <div id="subtitle">
          Left: heliocentric orbits. Right: zodiac wheel using Level-2 geocentric approximation (planet − Earth).
        </div>

        <div id="controls">
          <label>
            Date:
            <input type="date" id="datePicker" />
          </label>

          <label>
            Time flow:
            <select id="speedSelect">
              <option value="realtime">Real-time</option>
              <option value="hour">1 hour / sec</option>
              <option value="day">1 day / sec</option>
              <option value="month">1 month / sec</option>
              <option value="year">1 year / sec</option>
              <option value="century">1 century / sec</option>
            </select>
          </label>

          <button id="todayBtn">Today (Live)</button>

          <span class="zoom-label">Helios Zoom:</span>
          <button id="zoomIn">+</button>
          <button id="zoomOut">−</button>

          <span class="zoom-label">Wheel Zoom:</span>
          <button id="wheelZoomIn">+</button>
          <button id="wheelZoomOut">−</button>

          <!-- NEW: toggle planet labels on the geocentric wheel -->
          <label style="gap:6px;">
            <input type="checkbox" id="toggleWheelLabels" checked />
            Wheel labels
          </label>
        </div>

        <div id="statusbar">
          <span class="chip" id="statusDate">DATE: —</span>
          <span class="chip" id="statusTime">TIME: —</span>
          <span class="chip" id="statusMode">MODE: —</span>
        </div>
      </div>

      <div id="panes">
        <div class="pane">
          <div class="pane-title">Heliocentric</div>
          <canvas id="canvasHelios"></canvas>
        </div>

        <div class="pane">
          <div class="pane-title">Zodiac Wheel (Geocentric)</div>
          <canvas id="canvasZodiac"></canvas>
        </div>
      </div>

      <div id="legend"></div>
    </div>
  </div>

  <script>
    const canvasHelios = document.getElementById('canvasHelios');
    const ctxH = canvasHelios.getContext('2d');

    const canvasZodiac = document.getElementById('canvasZodiac');
    const ctxZ = canvasZodiac.getContext('2d');

    const datePicker = document.getElementById('datePicker');
    const todayBtn = document.getElementById('todayBtn');
    const zoomInBtn = document.getElementById('zoomIn');
    const zoomOutBtn = document.getElementById('zoomOut');
    const wheelZoomInBtn = document.getElementById('wheelZoomIn');
    const wheelZoomOutBtn = document.getElementById('wheelZoomOut');
    const speedSelect = document.getElementById('speedSelect');

    const statusDate = document.getElementById('statusDate');
    const statusTime = document.getElementById('statusTime');
    const statusMode = document.getElementById('statusMode');

    // NEW: toggle for geocentric wheel planet labels
    const toggleWheelLabels = document.getElementById('toggleWheelLabels');
    let showWheelLabels = true;
    toggleWheelLabels.addEventListener('change', () => {
      showWheelLabels = toggleWheelLabels.checked;
    });

    let selectedDate = null;
    let zoomFactor = 1.0;       // Helios zoom
    let wheelZoom = 1.0;        // Zodiac wheel zoom
    let simJD = null;
    let lastFrameTime = null;
    let speedMode = 'realtime';

    function resizeCanvases() {
      [canvasHelios, canvasZodiac].forEach(c => {
        const rect = c.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        c.width = Math.max(2, Math.floor(rect.width * dpr));
        c.height = Math.max(2, Math.floor(rect.height * dpr));
      });
    }
    window.addEventListener('resize', () => {
      resizeCanvases();
      lastFrameTime = null;
    });
    resizeCanvases();

    function getJulianDate(date) {
      return date.getTime() / 86400000 + 2440587.5;
    }

    function jdToDate(jd) {
      const ms = (jd - 2440587.5) * 86400000;
      return new Date(ms);
    }

    function fmtDate(d) {
      const y = d.getUTCFullYear();
      const m = String(d.getUTCMonth() + 1).padStart(2, '0');
      const day = String(d.getUTCDate()).padStart(2, '0');
      return `${y}-${m}-${day}`;
    }

    function fmtTime(d) {
      const hh = String(d.getUTCHours()).padStart(2, '0');
      const mm = String(d.getUTCMinutes()).padStart(2, '0');
      const ss = String(d.getUTCSeconds()).padStart(2, '0');
      return `${hh}:${mm}:${ss} UTC`;
    }

    const planetConfigs = [
      { name:'Sun',     color:'#ffd700', type:'star', radiusKm:696340, faceType:null, meanAU:0 },
      { name:'Mercury', color:'#c0c0c0', type:'kepler', radiusKm:2440, faceType:'triangle', meanAU:0.38709927 },
      { name:'Venus',   color:'#ffbf7f', type:'kepler', radiusKm:6052, faceType:'square', meanAU:0.72333566 },
      { name:'Earth',   color:'#4cc9f0', type:'kepler', radiusKm:6371, faceType:'pentagon', meanAU:1.00000261 },
      { name:'Mars',    color:'#ff6b6b', type:'kepler', radiusKm:3390, faceType:'triangle', meanAU:1.52371034 },
      { name:'Jupiter', color:'#ffdd99', type:'kepler', radiusKm:69911, faceType:'square', meanAU:5.20288700 },
      { name:'Saturn',  color:'#f4e285', type:'kepler', radiusKm:58232, faceType:'pentagon', meanAU:9.53667594 },
      { name:'Uranus',  color:'#7fffd4', type:'kepler', radiusKm:25362, faceType:'triangle', meanAU:19.18916464 },
      { name:'Neptune', color:'#6c5ce7', type:'kepler', radiusKm:24622, faceType:'square', meanAU:30.06992276 },
      { name:'Pluto',   color:'#b388ff', type:'plutoSimple', radiusKm:1188, faceType:'pentagon', meanAU:39.48, periodYears:248, phaseDeg0:238 }
    ];

    const keplerElements = {
      Mercury:{ a0:0.38709927,aDot:0.00000037, e0:0.20563593,eDot:0.00001906, I0:7.00497902,IDot:-0.00594749,
                L0:252.25032350,LDot:149472.67411175, wBar0:77.45779628,wBarDot:0.16047689, Omega0:48.33076593,OmegaDot:-0.12534081 },
      Venus:  { a0:0.72333566,aDot:0.00000390, e0:0.00677672,eDot:-0.00004107, I0:3.39467605,IDot:-0.00078890,
                L0:181.97909950,LDot:58517.81538729, wBar0:131.60246718,wBarDot:0.00268329, Omega0:76.67984255,OmegaDot:-0.27769418 },
      Earth:  { a0:1.00000261,aDot:0.00000562, e0:0.01671123,eDot:-0.00004392, I0:-0.00001531,IDot:-0.01294668,
                L0:100.46457166,LDot:35999.37244981, wBar0:102.93768193,wBarDot:0.32327364, Omega0:0.0,OmegaDot:0.0 },
      Mars:   { a0:1.52371034,aDot:0.00001847, e0:0.09339410,eDot:0.00007882, I0:1.84969142,IDot:-0.00813131,
                L0:-4.55343205,LDot:19140.30268499, wBar0:-23.94362959,wBarDot:0.44441088, Omega0:49.55953891,OmegaDot:-0.29257343 },
      Jupiter:{ a0:5.20288700,aDot:-0.00011607, e0:0.04838624,eDot:-0.00013253, I0:1.30439695,IDot:-0.00183714,
                L0:34.39644051,LDot:3034.74612775, wBar0:14.72847983,wBarDot:0.21252668, Omega0:100.47390909,OmegaDot:0.20469106 },
      Saturn: { a0:9.53667594,aDot:-0.00125060, e0:0.05386179,eDot:-0.00050991, I0:2.48599187,IDot:0.00193609,
                L0:49.95424423,LDot:1222.49362201, wBar0:92.59887831,wBarDot:-0.41897216, Omega0:113.66242448,OmegaDot:-0.28867794 },
      Uranus: { a0:19.18916464,aDot:-0.00196176, e0:0.04725744,eDot:-0.00004397, I0:0.77263783,IDot:-0.00242939,
                L0:313.23810451,LDot:428.48202785, wBar0:170.95427630,wBarDot:0.40805281, Omega0:74.01692503,OmegaDot:0.04240589 },
      Neptune:{ a0:30.06992276,aDot:0.00026291, e0:0.00859048,eDot:0.00005105, I0:1.77004347,IDot:0.00035372,
                L0:-55.12002969,LDot:218.45945325, wBar0:44.96476227,wBarDot:-0.32241464, Omega0:131.78422574,OmegaDot:-0.00508664 }
    };

    // Legend order in rows of 3
    const legendOrder = [
      ['Sun'],
      ['Mercury', 'Venus', 'Earth'],
      ['Mars', 'Jupiter', 'Saturn'],
      ['Neptune', 'Uranus'],
      ['Pluto']
    ];
    const legend = document.getElementById('legend');
    legend.innerHTML = '';
    legendOrder.flat().forEach(name => {
      const p = planetConfigs.find(x => x.name === name);
      const item = document.createElement('div');
      item.className = 'legend-item';
      const dot = document.createElement('div');
      dot.className = 'legend-dot ' + p.name.toLowerCase();
      const label = document.createElement('span');
      label.textContent = p.name;
      item.appendChild(dot);
      item.appendChild(label);
      legend.appendChild(item);
    });

    datePicker.addEventListener('change', () => {
      if (datePicker.value) {
        selectedDate = new Date(datePicker.value + 'T00:00:00Z');
        simJD = getJulianDate(selectedDate);
      } else {
        selectedDate = null;
        simJD = null;
      }
      lastFrameTime = null;
    });

    todayBtn.addEventListener('click', () => {
      selectedDate = null;
      datePicker.value = '';
      simJD = null;
      lastFrameTime = null;
    });

    zoomInBtn.addEventListener('click', () => {
      zoomFactor *= 1.2;
      if (zoomFactor > 8) zoomFactor = 8;
      lastFrameTime = null;
    });

    zoomOutBtn.addEventListener('click', () => {
      zoomFactor /= 1.2;
      if (zoomFactor < 0.2) zoomFactor = 0.2;
      lastFrameTime = null;
    });

    wheelZoomInBtn.addEventListener('click', () => {
      wheelZoom *= 1.15;
      if (wheelZoom > 4) wheelZoom = 4;
      lastFrameTime = null;
    });

    wheelZoomOutBtn.addEventListener('click', () => {
      wheelZoom /= 1.15;
      if (wheelZoom < 0.4) wheelZoom = 0.4;
      lastFrameTime = null;
    });

    speedSelect.addEventListener('change', () => {
      speedMode = speedSelect.value;
      lastFrameTime = null;
      statusMode.textContent = `MODE: ${speedMode.toUpperCase()}`;
    });

    const JD_J2000 = 2451545.0;

    function getSpeedDaysPerSecond(mode) {
      switch (mode) {
        case 'hour':    return 1 / 24;
        case 'day':     return 1;
        case 'month':   return 30;
        case 'year':    return 365.25;
        case 'century': return 36525;
        case 'realtime':
        default:        return 1 / 86400;
      }
    }

    const earthRadiusKm = 6371;
    function getPlanetDotRadius(planet) {
      if (planet.name === 'Sun') return 8;
      const ratio = planet.radiusKm / earthRadiusKm;
      const scaled = Math.cbrt(ratio);
      let px = 3 * scaled;
      if (px < 2) px = 2;
      if (px > 10) px = 10;
      return px;
    }

    function getSidesFromFace(faceType) {
      if (faceType === 'triangle') return 3;
      if (faceType === 'square')   return 4;
      if (faceType === 'pentagon') return 5;
      return 0;
    }

    function solveKepler(M, e) {
      let E = M;
      for (let i = 0; i < 6; i++) {
        const f = E - e * Math.sin(E) - M;
        const fPrime = 1 - e * Math.cos(E);
        E = E - f / fPrime;
      }
      return E;
    }

    function getKeplerXY(name, jd) {
      const el = keplerElements[name];
      const T = (jd - JD_J2000) / 36525.0;

      const a = el.a0 + el.aDot * T;
      const e = el.e0 + el.eDot * T;
      const I = (el.I0 + el.IDot * T) * Math.PI / 180;
      const L = (el.L0 + el.LDot * T) * Math.PI / 180;
      const wBar = (el.wBar0 + el.wBarDot * T) * Math.PI / 180;
      const Omega = (el.Omega0 + el.OmegaDot * T) * Math.PI / 180;

      const omega = wBar - Omega;
      let M = L - wBar;
      M = ((M + Math.PI) % (2 * Math.PI)) - Math.PI;

      const E = solveKepler(M, e);

      const xPrime = a * (Math.cos(E) - e);
      const yPrime = a * Math.sqrt(1 - e * e) * Math.sin(E);

      const cosO = Math.cos(Omega), sinO = Math.sin(Omega);
      const cosI = Math.cos(I);
      const cosW = Math.cos(omega), sinW = Math.sin(omega);

      const x1 =  cosW * xPrime - sinW * yPrime;
      const y1 =  sinW * xPrime + cosW * yPrime;

      const xEcl = x1 * cosO - y1 * sinO * cosI;
      const yEcl = x1 * sinO + y1 * cosO * cosI;

      return { x: xEcl, y: yEcl, a: a };
    }

    function getPlutoXY(config, jd) {
      const Tyears = (jd - JD_J2000) / 365.25;
      const angleDeg = config.phaseDeg0 + (360 * Tyears / config.periodYears);
      const angle = angleDeg * Math.PI / 180;
      const r = config.meanAU;
      return { x: r * Math.cos(angle), y: r * Math.sin(angle), a: config.meanAU };
    }

    function normalizeAngleRad(a) {
      a = a % (2 * Math.PI);
      if (a < 0) a += 2 * Math.PI;
      return a;
    }

    // Zodiac helpers
    const zodiac = [
      { name: 'Aries', symbol: '♈' },
      { name: 'Taurus', symbol: '♉' },
      { name: 'Gemini', symbol: '♊' },
      { name: 'Cancer', symbol: '♋' },
      { name: 'Leo', symbol: '♌' },
      { name: 'Virgo', symbol: '♍' },
      { name: 'Libra', symbol: '♎' },
      { name: 'Scorpio', symbol: '♏' },
      { name: 'Sagittarius', symbol: '♐' },
      { name: 'Capricorn', symbol: '♑' },
      { name: 'Aquarius', symbol: '♒' },
      { name: 'Pisces', symbol: '♓' }
    ];

    // 0° Aries at TOP (12 o'clock), increasing CCW
    function lonToCanvasAngle(lonRad) {
      return -(lonRad - Math.PI / 2);
    }

    function drawZodiacWheel(helioPositions) {
      const w = canvasZodiac.width;
      const h = canvasZodiac.height;
      const cx = w / 2;
      const cy = h / 2;

      ctxZ.clearRect(0, 0, w, h);

      const baseR = (Math.min(cx, cy) - 18) * wheelZoom;

      const glow = ctxZ.createRadialGradient(cx, cy, 0, cx, cy, baseR * 0.45);
      glow.addColorStop(0, 'rgba(255, 215, 0, 0.25)');
      glow.addColorStop(0.6, 'rgba(255, 215, 0, 0.06)');
      glow.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctxZ.fillStyle = glow;
      ctxZ.beginPath();
      ctxZ.arc(cx, cy, baseR * 0.55, 0, Math.PI * 2);
      ctxZ.fill();

      // Outer rings
      ctxZ.beginPath();
      ctxZ.strokeStyle = 'rgba(255,215,0,0.22)';
      ctxZ.lineWidth = 2;
      ctxZ.arc(cx, cy, baseR, 0, Math.PI * 2);
      ctxZ.stroke();

      ctxZ.beginPath();
      ctxZ.strokeStyle = 'rgba(255,215,0,0.12)';
      ctxZ.lineWidth = 1;
      ctxZ.arc(cx, cy, baseR * 0.84, 0, Math.PI * 2);
      ctxZ.stroke();

      // 12 sectors + sign labels
      // "as you described": larger than before, with your later tweak baked in
      const signFontPx = Math.max(10, Math.floor(12 * (window.devicePixelRatio || 1))) * 2.2;

      for (let i = 0; i < 12; i++) {
        const lon0 = i * (2 * Math.PI / 12);
        const a = lonToCanvasAngle(lon0);

        ctxZ.beginPath();
        ctxZ.strokeStyle = 'rgba(255,255,255,0.10)';
        ctxZ.lineWidth = 1;
        ctxZ.moveTo(cx, cy);
        ctxZ.lineTo(cx + Math.cos(a) * baseR, cy + Math.sin(a) * baseR);
        ctxZ.stroke();

        // Sign label position (mid-sector)
        const lonMid = lon0 + (Math.PI / 12);
        const am = lonToCanvasAngle(lonMid);
        const tx = cx + Math.cos(am) * (baseR * 0.90);
        const ty = cy + Math.sin(am) * (baseR * 0.90);

        ctxZ.font = `${signFontPx}px system-ui`;
        ctxZ.fillStyle = 'rgba(255,215,0,0.72)';
        ctxZ.textAlign = 'center';
        ctxZ.textBaseline = 'middle';
        ctxZ.fillText(zodiac[i].symbol, tx, ty);
      }

      // Degree ticks every 10°
      for (let deg = 0; deg < 360; deg += 10) {
        const lon = deg * Math.PI / 180;
        const a = lonToCanvasAngle(lon);
        const r1 = baseR * 0.98;
        const r2 = (deg % 30 === 0) ? baseR * 0.90 : baseR * 0.94;

        ctxZ.beginPath();
        ctxZ.strokeStyle = (deg % 30 === 0) ? 'rgba(255,215,0,0.22)' : 'rgba(255,255,255,0.08)';
        ctxZ.lineWidth = (deg % 30 === 0) ? 1.6 : 1;
        ctxZ.moveTo(cx + Math.cos(a) * r1, cy + Math.sin(a) * r1);
        ctxZ.lineTo(cx + Math.cos(a) * r2, cy + Math.sin(a) * r2);
        ctxZ.stroke();
      }

      // Geocentric longitudes (Level 2): planet - Earth
      const earth = helioPositions['Earth'];
      const geo = {};
      planetConfigs.forEach(p => {
        if (p.name === 'Earth') return;

        if (p.name === 'Sun') {
          const gx = -earth.x;
          const gy = -earth.y;
          geo[p.name] = { x: gx, y: gy, lon: normalizeAngleRad(Math.atan2(gy, gx)) };
          return;
        }

        const hp = helioPositions[p.name];
        if (!hp) return;
        const gx = hp.x - earth.x;
        const gy = hp.y - earth.y;
        geo[p.name] = { x: gx, y: gy, lon: normalizeAngleRad(Math.atan2(gy, gx)) };
      });

      // Plot markers on a ring (pulled inward for label breathing room)
      const markerR = baseR * 0.66;

      function markerSize(name) {
        if (name === 'Sun') return 7;
        if (name === 'Jupiter' || name === 'Saturn') return 6;
        return 5;
      }

      function drawMarker(name, color, lon, radiusPx, label) {
        const a = lonToCanvasAngle(lon);
        const x = cx + Math.cos(a) * markerR;
        const y = cy + Math.sin(a) * markerR;

        // marker dot
        ctxZ.beginPath();
        ctxZ.fillStyle = color;
        ctxZ.shadowBlur = 10;
        ctxZ.shadowColor = color;
        ctxZ.arc(x, y, radiusPx, 0, Math.PI * 2);
        ctxZ.fill();
        ctxZ.shadowBlur = 0;

        // small tick inward
        ctxZ.beginPath();
        ctxZ.strokeStyle = 'rgba(255,215,0,0.35)';
        ctxZ.lineWidth = 1;
        ctxZ.moveTo(x, y);
        ctxZ.lineTo(cx + Math.cos(a) * (markerR * 0.93), cy + Math.sin(a) * (markerR * 0.93));
        ctxZ.stroke();

        if (!showWheelLabels) return;

        // label
        ctxZ.font = `${Math.max(9, Math.floor(10 * (window.devicePixelRatio || 1)))}px system-ui`;
        ctxZ.fillStyle = 'rgba(255,255,255,0.85)';
        ctxZ.textAlign = (Math.cos(a) > 0) ? 'left' : 'right';
        ctxZ.textBaseline = 'middle';

        const lx = x + (Math.cos(a) > 0 ? 14 : -14);
        const ly = y;

        const lonDeg = lon * 180 / Math.PI;
        const signIndex = Math.floor(lonDeg / 30);
        const degIntoSign = lonDeg - signIndex * 30;

        const txt = `${label} ${zodiac[signIndex].symbol} ${degIntoSign.toFixed(0)}°`;
        ctxZ.fillText(txt, lx, ly);
      }

      const order = ['Sun','Mercury','Venus','Mars','Jupiter','Saturn','Uranus','Neptune','Pluto'];
      order.forEach(n => {
        const p = planetConfigs.find(x => x.name === n);
        const g = geo[n];
        if (!p || !g) return;
        const rPx = markerSize(n) * (window.devicePixelRatio || 1) * 0.6;
        drawMarker(n, p.color, g.lon, rPx, n);
      });

      // Center point
      ctxZ.beginPath();
      ctxZ.fillStyle = 'rgba(255,215,0,0.35)';
      ctxZ.arc(cx, cy, 3.2 * (window.devicePixelRatio || 1), 0, Math.PI * 2);
      ctxZ.fill();
    }

    function drawHelios(positions) {
      const w = canvasHelios.width;
      const h = canvasHelios.height;
      const cx = w / 2;
      const cy = h / 2;

      ctxH.clearRect(0, 0, w, h);

      const maxAU = 50;
      const scale = (Math.min(cx, cy) - 40) * zoomFactor / maxAU;

      const glow = ctxH.createRadialGradient(cx, cy, 0, cx, cy, 80 * zoomFactor);
      glow.addColorStop(0, 'rgba(255, 215, 0, 0.6)');
      glow.addColorStop(0.4, 'rgba(255, 215, 0, 0.15)');
      glow.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctxH.fillStyle = glow;
      ctxH.beginPath();
      ctxH.arc(cx, cy, 80 * zoomFactor, 0, Math.PI * 2);
      ctxH.fill();

      // Orbits
      planetConfigs.forEach(p => {
        if (p.name === 'Sun') return;
        const orbitRadiusPx = p.meanAU * scale;
        ctxH.beginPath();
        ctxH.strokeStyle = 'rgba(255, 215, 0, 0.15)';
        ctxH.lineWidth = 1;
        ctxH.arc(cx, cy, orbitRadiusPx, 0, Math.PI * 2);
        ctxH.stroke();
      });

      // Bodies + polygon traces
      planetConfigs.forEach(p => {
        if (p.name === 'Sun') {
          const sunRadius = 8 * (window.devicePixelRatio || 1) * 0.6;
          ctxH.beginPath();
          ctxH.fillStyle = p.color;
          ctxH.shadowBlur = 20;
          ctxH.shadowColor = p.color;
          ctxH.arc(cx, cy, sunRadius, 0, Math.PI * 2);
          ctxH.fill();
          ctxH.shadowBlur = 0;
          return;
        }

        const pos = positions[p.name];
        if (!pos) return;

        const xAU = pos.x;
        const yAU = pos.y;
        const rAU = Math.sqrt(xAU * xAU + yAU * yAU);

        const xPx = cx + xAU * scale;
        const yPx = cy + yAU * scale;

        // Polygon face trace
        const sides = getSidesFromFace(p.faceType);
        if (sides >= 3) {
          const baseAngle = Math.atan2(yAU, xAU);
          ctxH.beginPath();
          ctxH.strokeStyle = 'rgba(255, 215, 0, 0.85)';
          ctxH.lineWidth = 0.9;
          for (let i = 0; i <= sides; i++) {
            const theta = baseAngle + (i * 2 * Math.PI / sides);
            const vx = cx + rAU * Math.cos(theta) * scale;
            const vy = cy + rAU * Math.sin(theta) * scale;
            if (i === 0) ctxH.moveTo(vx, vy);
            else ctxH.lineTo(vx, vy);
          }
          ctxH.stroke();
        }

        // Planet dot
        const dotRadius = getPlanetDotRadius(p) * (window.devicePixelRatio || 1) * 0.6;
        ctxH.beginPath();
        ctxH.fillStyle = p.color;
        ctxH.shadowBlur = 8;
        ctxH.shadowColor = p.color;
        ctxH.arc(xPx, yPx, dotRadius, 0, Math.PI * 2);
        ctxH.fill();
        ctxH.shadowBlur = 0;
      });

      // Outer subtle ring
      ctxH.beginPath();
      ctxH.strokeStyle = 'rgba(255, 255, 255, 0.15)';
      ctxH.lineWidth = 0.5;
      ctxH.arc(cx, cy, Math.min(cx, cy) - 6, 0, Math.PI * 2);
      ctxH.stroke();
    }

    function computeHelioPositions(jd) {
      const positions = {};
      planetConfigs.forEach(p => {
        if (p.type === 'kepler') positions[p.name] = getKeplerXY(p.name, jd);
        else if (p.type === 'plutoSimple') positions[p.name] = getPlutoXY(p, jd);
      });
      return positions;
    }

    // initialize status
    statusMode.textContent = `MODE: ${speedMode.toUpperCase()}`;

    function draw() {
      const nowPerf = performance.now() / 1000;
      if (lastFrameTime === null) lastFrameTime = nowPerf;
      const dtReal = nowPerf - lastFrameTime;
      lastFrameTime = nowPerf;

      let jd;

      if (!selectedDate && speedMode === 'realtime') {
        jd = getJulianDate(new Date());
        simJD = null;
      } else {
        if (simJD === null) simJD = getJulianDate(selectedDate || new Date());
        simJD += dtReal * getSpeedDaysPerSecond(speedMode);
        jd = simJD;
      }

      // update status bar from simulated JD
      const d = jdToDate(jd);
      statusDate.textContent = `DATE: ${fmtDate(d)}`;
      statusTime.textContent = `TIME: ${fmtTime(d)}`;
      statusMode.textContent = `MODE: ${speedMode.toUpperCase()}`;

      const helioPositions = computeHelioPositions(jd);

      drawHelios(helioPositions);
      drawZodiacWheel(helioPositions);

      requestAnimationFrame(draw);
    }

    draw();
  </script>
</body>
</html>
